# -*- coding: utf-8 -*-
"""clustering of countries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pqHAIpw4BjVQA5hUiD09lquj9NX4PDkL
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df= pd.read_csv('/content/Country-data.csv')

df.head()

df_dic= pd.read_csv('/content/data-dictionary.csv')

df_dic.head()

df.info()

df.describe()

sns.heatmap(df.corr())

df.isnull().sum()

df.eq(0).sum()

df.duplicated().sum()

df.nunique()

import plotly.express as px
columns=['country', 'child_mort', 'exports', 'health', 'imports', 'income',
       'inflation', 'life_expec', 'total_fer', 'gdpp']

colors = ["rgb(255, 51, 51)", "rgb(210, 231, 154)", "rgb(94, 179, 39)", "rgb(67, 136, 33)", "rgb(33, 74, 12)"]

for i in columns:
  fig = px.choropleth(df,
                    locationmode='country names',
                    locations='country',
                    color= i,
                    title='Show the differences in Countries by '+ i,
                    color_continuous_scale=colors
                   )

  fig.show()

# columns=['country', 'child_mort', 'exports', 'health', 'imports', 'income',
#        'inflation', 'life_expec', 'total_fer', 'gdpp']

# fig, ax= plt.subplots(nrows=3, ncols= 3, figsize=(20,13))
# for i in range(len(columns)):
#    plt.subplot(3,3,i+1)
#     sns.distplot(df[columns[i]],color ='#8B4513' )
#     plt.title("show the distribution of " + columns[i], fontsize=10)
# plt.show()

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Child Mort', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.child_mort, showmeans=True, orient='h')

# ax[1]
df.child_mort.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.child_mort > 200]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Exports', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.exports, showmeans=True, orient='h')

# ax[1]
df.exports.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.exports > 125]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Health', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.health, showmeans=True, orient='h')

# ax[1]
df.health.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.health > 14]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Imports', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.imports, showmeans=True, orient='h')

# ax[1]
df.imports.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.imports > 125]

#imports and exports >125 are the same countries.

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Income', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.income, showmeans=True, orient='h')

# ax[1]
df.income.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.income > 60000]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Inflation', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.inflation, showmeans=True, orient='h')

# ax[1]
df.inflation.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.inflation > 40]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Life_expec', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.life_expec, showmeans=True, orient='h')

# ax[1]
df.life_expec.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.life_expec <50]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('Total_fer', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.total_fer, showmeans=True, orient='h')

# ax[1]
df.total_fer.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.total_fer> 7]

fig , ax = plt.subplots(1, 2, figsize=(15, 5))
fig.tight_layout(pad=5.0)
fig.suptitle('gdpp', fontweight='bold', fontsize=25.0, color='navy')
# ax[0]
sns.boxplot(ax=ax[0], data=df.gdpp, showmeans=True, orient='h')

# ax[1]
df.gdpp.hist().set(xticks=range(0, 250,  50))
plt.show()

df[df.gdpp> 60000]

df1 = df.drop(columns='country')

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA, IncrementalPCA

standard_scaler = StandardScaler().fit_transform(df1)
df2 = pd.DataFrame(standard_scaler, columns=columns[1:])
df2

pca = PCA(svd_solver='randomized', random_state=42, n_components=9).fit(df2)
exp = pca.explained_variance_ratio_
exp

plt.plot(np.cumsum(exp), linewidth=3)
plt.title('n_component - Cumulative variance')
plt.xlabel('Number of n_components')
plt.ylabel('Cumulative Explained Variance Ratio')
plt.xticks(range(0, 10, 1))
plt.yticks(np.arange(0, 1.1, 0.1))
plt.show()

#when n_components= 5, the score is approx 95%

pca_df = pd.DataFrame({
    'Features' : columns[1:],
    'PC1' : pca.components_[0],
    'PC2' : pca.components_[1],
    'PC3' : pca.components_[2],
    'PC4' : pca.components_[3],
    'PC5' : pca.components_[4],
})
pca_df

plt.scatter(pca_df.PC1,pca_df.PC2)
plt.xlabel('PC1')
plt.ylabel('PC2')
for i, txt in enumerate(pca_df.Features):
    plt.annotate(txt, (pca_df.PC1[i],pca_df.PC2[i]))
plt.show()

pca_final = IncrementalPCA(n_components=5)

df_pca = pca_final.fit_transform(df2)
df_pca.shape

pc = np.transpose(df_pca)

pca_df2 = pd.DataFrame({
    'PC1':pc[0],
    'PC2':pc[1],
    'PC3':pc[2],
    'PC4':pc[3],
    'PC5':pc[4],
})
pca_df2

fig = plt.figure(figsize = (15,6))
sns.boxplot(data=pca_df2)
plt.show()

from sklearn.cluster import KMeans

kmeans_set = {
    'init' : 'random',
    'n_init' : 10,
    'max_iter' : 300,
    'random_state' : 42
}

list_kmeans = []

for k in range(2, 10) :
    kmeans = KMeans(n_clusters=k, **kmeans_set)
    kmeans.fit(pca_df2)
    list_kmeans.append(kmeans.inertia_)

pca_df2.head()

list_kmeans

print('Minimum inertia', min(list_kmeans))
print('Number of clusters :', list_kmeans.index(min(list_kmeans))+2)
print('_'*50)
print('Maximum inertia', max(list_kmeans))
print('Number of clusters :', list_kmeans.index(max(list_kmeans))+2)

